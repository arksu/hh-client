# Introduction #

все скрипты должны иметь расширение файла .bot
F2 - старт скрипта test.bot, если уже выполняется ничего не произойдет. надо сначала остановить работающий
F3 - стоп выполнения любого скрипта
:bot 

&lt;name&gt;

 - команда набирается просто в окне, не надо ни в чат ни куда либо. это системная консоль хнх включается по символу двоеточие ":". имя указывается без расширения .bot

:set\_bot1 

&lt;NAME&gt;


:set\_bot2 

&lt;NAME&gt;


ставит имена скриптов для F1 и F2 соответственно.

соответственно на F1 F2 вешаем имена скриптов
 ОПИСАНИЕ ЯЗЫКА 
язык основан на Си. синтаксис аналогичен.

все ключевые операторы и знаки регистрозависимы! работают только в нижнем регистре! (if, while, return, break...)
переменные. пока только одного типа int
массивы. поддерживаются одномерные массивы
операции: && ! || + - / **(-) < > != == >= <= (все с корректными приоритетами)
применима префиксная и постфиксная запись к переменным целого типа (a++, --b)
функции. объявляются аналогично Си. одно глобальное пространство имен. фукнции возвращают пока только int или ничего (нет return).
можно переопределять фукнции с разными параметрами. т.н. overload
инклуд. можно инклудить файлы. механизм аналогичен Си. директива "#include**

&lt;name&gt;

"  указываются всегда в начале файла
нужный файл просто встраивается на место директивы
блоки. блоки операторов огораживаются {} допускается произвольная вложенность. пространство имен внутри каждого блока локализуется

функция void main() - является точкой входа в скрипт. ее наличие обязательно

sleep(int time) - приостановить выполнение скрипта на указанное количество милисекунд
print(<что-то>) - вывести в консоль сообщение - либо число либо строку
exit - принудительный выход из скрипта
logout - выход из скрипта и логаут чара
say(string msg) - сказать в area чат

специфичные операторы (интегрированы в клиент хнх):

void do\_click(int objid, int btn, int mod)
> послать клик по объекту на карте. объект указывается по objid. кнопка мыши btn (1 - левая. 3 - правая). дополнительные флаги mod (1-шифт. 2-ктрл. 4-альт. 8-вин)
void map\_click(int x, int y, int btn, int mod)
> простой клик по карте. как обычно щелкаем мышью. только координаты относительно игрока
void map\_abs\_click(int x, int y, int btn, int mod)
> абсолютный клик по карте. как обычно щелкаем мышью. указываем координаты мира
void map\_move\_step(int x, int y)
> передвинутся на указанное количество тайлов от текущей позиции игрока, фактически это map\_click всегда с левой кнопкой
void map\_move(int objid, int x, int y)
> бежать к указанной точке. объект и оффсет от него в координатах карты. (1 тайл = 11 точек)
int my\_coord\_x()
int my\_coord\_y()
> получить мои мировые координаты (абсолютные)
void map\_interact\_click(int x, int y, int mod)
void map\_interact\_click(int objid, int mod)
> кликнуть по карте (взаимодействие, чтото держим в руках) координаты указываются в тайлах от текущей позиции игрока
void map\_abs\_interact\_click(int x, int y, int mod)
> то же самое только указываем абсолютные координаты
void map\_place(int x, int y, int btn, int mod)
> поставить объек который хотим построить в указанные координаты относительно игрока. координаты задаем в тайлах
void select\_context\_menu(string option\_name)
> выбрать опцию в контекстном выпадающем меню над объектом
void send\_action(string name)
> послать действие из меню внизу справа, с одним параметром. параметр видно при щелчке на кнопку в логе по ф12
> laystone - укладка камней. асфальтирование
> carry - перетаскивание объектов (lift)
void send\_action(string name, string name2)
> послать действие из меню внизу справа, если нужно указывать 2 параметра

int is\_cursor(string cursor\_name)
> проверяет стоит ли указанный курсор в данный момент
> dig - лопата
> chi - курсор пипетка. появляется когда хотим чето перетаскивать. и надо указать объект
void drop(int mod)
> дропнуть вещь в руках на землю

int input\_get\_object(string msg);
> сказать игроку выбрать объект мышкой. все объекты подсвечиваются зеленым. пользователь должен щелкнуть на какой нить объект тогда управление вернется в скрипт
> msg - выведет сообщение красным цветом на экран
int find\_object\_by\_name(string name, int radius)
> найти объект по имени, проверяется вхождение имени в имя ресурса, радиус в тайлах
int find\_object\_by\_type(string type, int radius)
> найти объект по типу, радиус в тайлах. доступные типы:
> > tree - дерево
int find\_map\_object(String name, int radius, int x, int y)

> найти объект по оффсету от себя в заданном радиусе и с заданным именем. ВНИМАНИЕ!!! радиус в точках карты. отступ в тайлах
> если имя не указано (пустая строка) ищет любой объект в заданном радиусе

int have\_inventory(string name)
> проверить наличие инвентаря по имени
void open\_inventory()
> открыть мой инвентарь
void set\_inventory(string name)
> поставить текущий инвентарь, после автоматически сбрасывается итератор
void reset\_inventory()
> сбросить итератор итемов в инвентаре
int next\_item()
> вызывать итератор для установки итема
> 0 - если вещи нет (прошли весь список). 1 если есть
int get\_items\_count()
> получить количество вещей в списке
void set\_item\_index(int index)
> установить текущую вещь по индексу в списке
void set\_item\_drag()
> установить текущей вещью - то что держим в руках если оно есть. (чтобы получить ее параметры)
void set\_item\_equip(int index)
> установить текущей вещью - вещь из инвентаря. указываем индекс (чтобы получить ее параметры)
получаем параметры текущей вещи установленной итератором
> int is\_item\_name(string name) - 0 или 1 совпадает ли имя вещи
> int is\_item\_tooltip(string name) - 0 или 1 совпадает ли тултип (всплывающая подсказка на вещи)
> int item\_quality() - возвращает качество
> void item\_click(string action) - щелчок по вещи
> void item\_click(string action, int mod) - щелчок по вещи, с модификатором клавиатуры
> > команды (action):
> > > take - взять вещь
> > > itemact - взаимодействие на вещь. чтото держим в руках и щелкаем правой кнопкой по вещи
> > > transfer - переместить. щелчек лкм с зажатым шифтом
> > > iact - фактически правый щелчек по вещи. для вызова контекстного меню
> > > drop - дропнуть вещь на землю. щелчек лкм с зажатым контролом

> int item\_coord\_x() - координаты вещи в инвентаре
> int item\_coord\_y()
> int item\_num() - получить цифру возле итема. пример: стадия червяков шелкопрядов. рисуетя вверху слева у вещи.
> int item\_meter() - получить прогресс итема. пример: сушка. круглешок на шкуре. принимаем значения от 0 до 100.
> void item\_drop(int x, int y) - положить вещь которую держим в руках в текущий инвентарь установленный set\_inventory. в указанные координаты. нумерация клеток с нуля
void inventory(string name, int x, int y, string action)
void inventory(string name, int x, int y, string action, int mod) - тоже самое но с модификатором клавиатуры
> дать команду вещи в инвентаре с указаныым именем. по указанным координатам вещи в этом инвентаре.
> > take - взять вещь
> > itemact - взаимодействие на вещь. чтото держим в руках и щелкаем правой кнопкой по вещи
> > transfer - переместить. щелчек лкм с зажатым шифтом
> > iact - фактически правый щелчек по вещи. для вызова контекстного меню
> > drop - дропнуть вещь на землю. щелчек лкм с зажатым контролом

void item\_drop\_to\_inventory(String name, int x, int y)

> дропнуть вещь в указанный инвентарь, допустим когда надо из моего инвентаря не закрывая его дропнуть в шкаф или ящик
int check\_craft(string wnd)
> проверить есть ли окно крафта с указанным заголовком
void wait\_craft(string wnd)
> подождать появления и готовности окна с указанным заголовком
void craft(int all)
> скрафтить вещь. all - 0 или 1. если 1 - то крафтим все. если 0 только одну вещь. перед крафтом надо каким то образом открыть окно крафта
void equip(int slot, string action)
> дать команду в эквип (одевалку), указываем какому слоту даем команду и саму команду
> слоты: hh\_slots.png
> команды:
> > take - взять вещь из слота
> > itemact - взаимодействие на вещь. чтото держим в руках и щелкаем правой кнопкой по вещи
> > transfer - переместить. щелчек лкм с зажатым шифтом
> > iact - фактически правый щелчек по вещи. для вызова контекстного меню
> > drop - дропнуть вещь которую держим в руках в указанный слот.

void render\_mode(int enabled)

> включить/выключить (0 или 1) рендер в клиенте. нужно для экономии ресурсов

int get\_object\_blob(int id, int index)
> получить данные из мессаги объекта. именно так задаются стадрии роста ( пример: get\_object\_blob(34676844, 0) вернет стадию роста указанного объекта если там есть данные. либо вернет 0)

void reset\_buff()
> сбросить итератор бафов
int next\_buff()
> перейти на следующий элемент баф листа. вернет либо 0 если уже конец. либо 1 если перешли на след бафф
int buff\_meter()
> вернет показатель шкалы под баффом (от 0 до 100)
int buff\_time\_meter()
> вернет оставшееся время до истечения баффа (от 0 до 100), чем ближе к 0 тем меньше времени осталось
int is\_buff\_name(string name)
> проверить имя баффа на вхождение строки. вернет 0 или 1
void build\_click()
> нажать кнопку строительства в окошке билда

игровые переменные:
> int HourGlass - 0 или 1 - есть песочные часы или нет
> int Hungry - абсолютное значение голода
> int HP - хп
> int Stamina - стамина
> int PlayerID - ид моего чара
> int Moving - 0 или 1 двигается ли мой персонаж
> int ContextMenuReady - 0 или 1 готово ли контекстное меню к работе (полностью раскрыто и готово к приему команды)
> int DraggingItem - 0 или 1 есть ли вещь в руках. перетаскиваем ли чего нибудь. НЕ над чаром. а в руках. то что бегает за курсором.
> int CraftReady - 0 или 1 готово ли окно крафта к приему команды
> int BuildReady - есть ли окно билда чего либо. 0 или 1